using Almanna;
using Gee;
namespace Parchment.Model.DB.Implementation {
	
	/**
	 * Almanna Implementation for class "Entry".
	 * Generated by almanna-generate.
	 */
	public class Entry : Parchment.Model.DB.Entity.Entry {
		public Publisher publisher { get; set; }
		public ArrayList<EntryTag> entry_tags { get; set; }

		public override void register_entity() {
			base.register_entity();

			add_has_one( "publisher", "publisher_id", "publisher_id" );
			add_has_many( "entry_tags", typeof(EntryTag), "entry_id", "entry_id" );
			add_has_many( "comments", typeof(Comment), "entry_id", "entry_id" );
		}

		/**
		 * Constructor to automatically set date_created to now when
		 * instantiated.
		 */
		public Entry() {
			base();
			this.date_created = new DateTime.now_local();
		}

		/**
		 * Override save to set date_modified on every update.
		 */
		public override void save() {
			this.date_modified = new DateTime.now_local();
			base.save();
		}

		/**
		 * Get comment count for entry.
		 */
		public int comment_count() {
			return (int) this.get_related_search("comments").count();
		}

		/**
		 * Get ArrayList of Comment objects.
		 */
		public ArrayList<Comment> comments() {
			var comments = this.get_related_search("comments")
							.order_by("date_created")
							.list();
			var real_comments = new ArrayList<Comment>();
			foreach ( var comment in comments ) {
				real_comments.add( (Comment) comment );
			}
			return real_comments;
		}

		/**
		 * Retrieve total entry count.
		 */
		public static int entry_count() {
			return (int) Entry.joined_search().count();
		}

		/**
		 * Retrieve a new Search with the publisher relationship.
		 */
		public static Search<Entry> joined_search() {
			return new Search<Entry>()              // Create a Search
						.relationship("publisher"); // Use publisher relationship
		}

		/**
		 * Get page of entries.
		 * @param page Page number
		 */
		public static Search<Entry> paged_entries( int page ) {
			return paged( Entry.joined_search(), page );
		}

		/**
		 * Retrieve a new search of entries referencing the given tag.
		 * @param tag_name Tag name
		 */
		public static TagPack paged_tag_entries( string tag_name, int page ) {
			var tag = new Search<Tag>().eq( "name", tag_name ).single();
			if ( tag == null ) {
				return new TagPack( 0, new ArrayList<Entry>() );
			}
			var entry_tags = tag.get_related_search("entry_tags");
			int count = (int) entry_tags.count();
			var entries = new ArrayList<Entry>();
			foreach ( var entry_tag in entry_tags.rows(10).page(page).list() ) {
				var entry = new Search<Entry>()
							.relationship("publisher")
							.lookup( ( (EntryTag) entry_tag ).entry_id );
				entries.add(entry);
			}
			return new TagPack( count, entries );
		}

		/**
		 * Add paging to existing search.
		 * @param page Page number
		 */
		public static Search<Entry> paged( Search<Entry> search, int page ) {
			return search
					.order_by( "date_created", true ) // Order by, descending
					.rows(10)                         // Show 10 entries per page
					.page(page);
		}

		/**
		 * Get number of tags for this entry.
		 */
		public int tag_count() {
			return (int) this.get_related_search("entry_tags").count();
		}

		/**
		 * Get a list of tags for this entry.
		 */
		public ArrayList<string> tags() {
			var tags = new ArrayList<string>();
			var entry_tags = this.get_related_search("entry_tags")
								.relationship("tag")
								.list();
			foreach ( var entry_tag in entry_tags ) {
				tags.add( ( (EntryTag) entry_tag ).tag.name );
			}
			return tags;
		}

		/**
		 * Add the given list of tags to an entry.
		 * @param tags Array of tag names
		 */
		public void add_tags( string[] tags ) {
			foreach ( var tag_name in tags ) {
				var tag = Tag.get_by_name(tag_name);
				var et_count = new Search<EntryTag>()
									.eq( "entry_id", this.entry_id )
									.eq( "tag_id", tag.tag_id )
									.count();
				if ( et_count == 0 ) {
					var et = new EntryTag();
					et.entry_id = this.entry_id;
					et.tag_id = tag.tag_id;
					et.save();
				}
			}
		}
	}

	/**
	 * Encapsulate a response from an list of entries from a tag, providing
	 * a count and the list of entries.
	 */
	public class TagPack : Object {
		public int count { get; set; default = 0; }
		public ArrayList<Entry> entries { get; set; }

		public TagPack( int count, ArrayList<Entry> entries ) {
			this.count = count;
			this.entries = entries;
		}
	}
}
